# -*- coding: utf-8 -*-
"""
@Author  : Chao Xue
@Time    : 2026/1/29 20:13
@Email   : xuechao@szbl.ac.cn
@Desc    : Merge GTFs of difference tools.
# This code is adapted from the GTF merging workflow described in
# Pau Clavell-Revelles et al., Nature Communications (2025),
# https://github.com/fairliereese/240706_pantranscriptome_cerberus_gtf_merge/blob/594b554f0235b5c0d1f40f789e7e0ecacecbbb9c/merge_only_ics/make_ic_gtf.py
# which integrates transcript annotations generated by multiple tools.
# The original implementation has been modified to fit the specific
# data structure and analysis requirements of this study.

"""
import os

import cerberus
import pyranges as pr
import pandas as pd
import argparse

def df_to_gtf(df):
    MAX_SPAN = 1000000
    gtf_entries = []

    for index, row in df.iterrows():
        chromosome = row['Chromosome']
        strand = row['Strand']
        ic_coords = list(map(int, row['ic'].split('-')))
        tss = row['tss']
        tes = row['tes']
        if abs(tss - tes) > MAX_SPAN:
            continue
        source = row['source']
        tools = source.split(',')

        # change tss and tes depending on strand to combat
        # off by one errors
        if strand == '+':
            tes += 1
        elif strand == '-':
            tss += 1

        # Ensure Start < End
        if tss > tes:
            tss, tes = tes, tss

        # Create transcript entry
        transcript_id = f"transcript_{index}"
        gtf_entries.append({
            'Chromosome': chromosome,
            'Source': 'GTOP',
            'Feature': 'transcript',
            'Start': tss,
            'End': tes,
            'Score': '.',
            'Strand': strand,
            'Frame': '.',
            'transcript_id': transcript_id,
            'tools': ','.join(tools)
        })

        # Generate exon entries
        exons = []
        if strand == '+':
            # For forward strand genes
            coords = [tss] + ic_coords + [tes]
            exons = [(coords[i], coords[i + 1]) for i in range(0,len(coords) - 1,2)]
        else:
            # For reverse strand genes
            coords = [tss] + ic_coords[::-1] + [tes]
            exons = [[coords[i], coords[i + 1]] for i in range(0,len(coords) - 1,2)][::-1]

        # Add exon entries
        for i, (start, end) in enumerate(exons):
            if start > end:
                start, end = end, start
            gtf_entries.append({
                'Chromosome': chromosome,
                'Source': 'GTOP',
                'Feature': 'exon',
                'Start': start,
                'End': end,
                'Score': '.',
                'Strand': strand,
                'Frame': '.',
                'transcript_id': transcript_id,
                'exon_number': f'{int(i + 1)}',
                'tools': ','.join(tools)
            })

    # Convert the list of entries to a DataFrame
    gtf_df = pd.DataFrame(gtf_entries, columns=[
        'Chromosome', 'Source', 'Feature', 'Start', 'End', 'Score', 'Strand', 'Frame', 'transcript_id', 'exon_number', 'tools'
    ])

    return gtf_df

def make_ic(gtf_files):

    gb_cols = ['Chromosome', 'Strand', 'ic']

    ic_df = pd.DataFrame()
    source_ic_df = pd.DataFrame()
    for tool_name,f in gtf_files.items():
        print(f'Processing {tool_name}')
        source = tool_name
        gtf_df = pr.read_gtf(f, duplicate_attr=True)
        print(gtf_df.df['Strand'].value_counts(dropna=False))
        gtf_df = gtf_df[gtf_df.Strand.isin(["+", "-"])]
        # gtf_df = gtf_df.df
        # gtf_df = pr.PyRanges(gtf_df)

        print(gtf_df.df['Strand'].value_counts(dropna=False))

        df = cerberus.get_ic(gtf_df)
        df['source'] = source

        print(df)
        # remove monoxonic
        df = df.loc[df.ic!='-']
        print(df)

        # agg. sources; groupby and add commas
        source_ic_df = pd.concat([source_ic_df, df[gb_cols+['source']]],
                                 axis=0)
        # remove dupes
        source_ic_df.drop_duplicates(inplace=True, keep='first')
        source_ic_df = source_ic_df.groupby(gb_cols, observed=True).agg({'source': ','.join}).reset_index()
        # merge to get starts for each sample-level thing
        tss_df = gtf_df.features.tss().df
        tes_df = gtf_df.features.tes().df

        tss_df = tss_df[['transcript_id', 'Start']].rename({'Start':'tss'}, axis=1)
        tes_df = tes_df[['transcript_id', 'Start']].rename({'Start':'tes'}, axis=1)

        df = df[gb_cols+['transcript_id']]
        df = df.merge(tss_df, how='left', on='transcript_id')
        df = df.merge(tes_df, how='left', on='transcript_id')
        df = df.drop('transcript_id', axis=1)

        # concat w/ original ic df
        ic_df = pd.concat([df, ic_df], axis=0)
        ic_df.drop_duplicates(inplace=True)

        # keep the longest for each
        fwd, rev = cerberus.get_stranded_gtf_dfs(ic_df)
        fwd = fwd.groupby(gb_cols, observed=True).agg(tss=("tss", "min"),
                                                      tes=("tes", "max")).reset_index()

        rev = rev.groupby(gb_cols, observed=True).agg(tss=("tss", "max"),
                                                      tes=("tes", "min")).reset_index()
        ic_df = pd.concat([fwd, rev], axis=0)

    # merge in sources
    ic_df = ic_df.merge(source_ic_df, on=gb_cols, how='left')

    # ic_df.to_csv(ofile, sep='\t', index=False)
    return ic_df

def main():
    # Set up argument parser
    parser = argparse.ArgumentParser(description="Process a GTF file to get unique intron chains.")
    parser.add_argument("input_gtfs", type=str, help="CFG file with paths to the input GTF file.")
    parser.add_argument("output_gtf", type=str, help="Path to the output CSV file for intron chains.")

    # Parse the arguments
    args = parser.parse_args()
    df = pd.read_csv(args.input_gtfs)
    gtfs = dict(zip(df['tool_name'], df['gtf_path']))

    # Process the GTF file
    df = make_ic(gtfs)
    df = df_to_gtf(df)

    df = pr.PyRanges(df)
    os.makedirs(os.path.dirname(args.output_gtf), exist_ok=True)
    df.to_gtf(args.output_gtf)

if __name__ == "__main__":
    main()
